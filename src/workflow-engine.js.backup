/**
 * Runtime Hub - Workflow Execution Engine
 * Handles execution of visual workflows with node-based processing
 */

class WorkflowEngine {
    constructor(io, config = null) {
        this.io = io;
        this.config = config || {
            workflow: {
                maxConcurrentWorkflows: 5,
                defaultTimeout: 60000,
                maxNodeExecutionTime: 30000,
                enableDebugLogging: true
            },
            pythonAgent: {
                timeout: 30000,
                maxRetries: 3
            }
        };
        this.runningWorkflows = new Map();
        this.nodeExecutors = new Map();
        this.executionQueue = [];
        this.isProcessing = false;
        
        // Performance metrics
        this.performanceMetrics = {
            totalWorkflows: 0,
            successfulWorkflows: 0,
            failedWorkflows: 0,
            averageExecutionTime: 0,
            totalExecutionTime: 0,
            nodeExecutions: 0,
            errorsByType: new Map()
        };
        
        // Workflow history for analytics
        this.workflowHistory = [];
        this.maxHistorySize = 1000;
        
        this.initializeNodeExecutors();
    }

    /**
     * Initialize node executors for different node types
     */
    initializeNodeExecutors() {
        // Control Flow Nodes
        this.nodeExecutors.set('Start', this.executeStart.bind(this));
        this.nodeExecutors.set('End', this.executeEnd.bind(this));
        this.nodeExecutors.set('Condition', this.executeCondition.bind(this));
        this.nodeExecutors.set('Loop', this.executeLoop.bind(this));
        this.nodeExecutors.set('Delay', this.executeDelay.bind(this));

        // Python Nodes
        this.nodeExecutors.set('Execute Python', this.executePython.bind(this));
        this.nodeExecutors.set('Monitor Function', this.executeMonitorFunction.bind(this));
        this.nodeExecutors.set('Import Module', this.executeImportModule.bind(this));

        // File System Nodes
        this.nodeExecutors.set('Read File', this.executeReadFile.bind(this));
        this.nodeExecutors.set('Write File', this.executeWriteFile.bind(this));
        this.nodeExecutors.set('List Directory', this.executeListDirectory.bind(this));

        // Windows System Nodes
        this.nodeExecutors.set('Run Command', this.executeRunCommand.bind(this));
        this.nodeExecutors.set('Start Process', this.executeStartProcess.bind(this));
        this.nodeExecutors.set('Kill Process', this.executeKillProcess.bind(this));

        // Network Nodes
        this.nodeExecutors.set('HTTP Request', this.executeHTTPRequest.bind(this));
        this.nodeExecutors.set('Download File', this.executeDownloadFile.bind(this));

        // Data Processing Nodes
        this.nodeExecutors.set('Transform JSON', this.executeTransformJSON.bind(this));
        this.nodeExecutors.set('Parse Text', this.executeParseText.bind(this));

        // Database Nodes
        this.nodeExecutors.set('SQL Query', this.executeSQLQuery.bind(this));

        // Notification Nodes
        this.nodeExecutors.set('Show Message', this.executeShowMessage.bind(this));

        // Logging Nodes
        this.nodeExecutors.set('Write Log', this.executeWriteLog.bind(this));

        // Automation Nodes
        this.nodeExecutors.set('Wait', this.executeDelay.bind(this));
        this.nodeExecutors.set('Keyboard Input', this.executeKeyboardInput.bind(this));

        // Security Nodes
        this.nodeExecutors.set('Encrypt Data', this.executeEncryptData.bind(this));
    }

    /**
     * Execute a workflow
     */
    async executeWorkflow(workflowId, nodes, connections) {
        if (this.config.workflow.enableDebugLogging) {
            console.log(`ðŸš€ Starting workflow execution: ${workflowId}`);
        }
        
        // Check concurrent workflow limit
        if (this.runningWorkflows.size >= this.config.workflow.maxConcurrentWorkflows) {
            throw new Error(`Maximum concurrent workflows (${this.config.workflow.maxConcurrentWorkflows}) reached`);
        }
        
        const workflow = {
            id: workflowId,
            nodes: nodes,
            connections: connections,
            executionState: new Map(), // node_id -> { status, data, error }
            startTime: Date.now(),
            status: 'running',
            cancelled: false // Simple cancellation flag
        };

        this.runningWorkflows.set(workflowId, workflow);

        try {
            // Find start node
            const startNode = nodes.find(n => n.type === 'Start');
            if (!startNode) {
                throw new Error('No Start node found in workflow');
            }

            // Execute workflow with timeout only
            await Promise.race([
                this.executeNode(workflow, startNode, connections),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Workflow execution timeout')), this.config.workflow.defaultTimeout)
                )
            ]);
            
            workflow.status = 'completed';
            workflow.endTime = Date.now();
            workflow.duration = workflow.endTime - workflow.startTime;
            
            if (this.config.workflow.enableDebugLogging) {
                console.log(`âœ… Workflow completed: ${workflowId} (${workflow.duration}ms)`);
            }
            this.broadcastWorkflowUpdate(workflowId, 'completed', workflow);
            
        } catch (error) {
            // Check if workflow was cancelled
            if (workflow.cancelled) {
                workflow.status = 'stopped';
                workflow.endTime = Date.now();
                workflow.duration = workflow.endTime - workflow.startTime;
                
                if (this.config.workflow.enableDebugLogging) {
                    console.log(`ðŸ›‘ Workflow stopped: ${workflowId} (${workflow.duration}ms)`);
                }
                this.broadcastWorkflowUpdate(workflowId, 'stopped', workflow);
            } else {
                workflow.status = 'error';
                workflow.error = error.message;
                workflow.endTime = Date.now();
                workflow.duration = workflow.endTime - workflow.startTime;
                
                console.error(`âŒ Workflow failed: ${workflowId} - ${error.message}`);
                this.broadcastWorkflowUpdate(workflowId, 'error', workflow);
            }
        }

        // Update metrics and history
        this.updateMetrics(workflow);
        this.addToHistory(workflow);

        return workflow;
    }

    /**
     * Update performance metrics
     */
    updateMetrics(workflow) {
        this.performanceMetrics.totalWorkflows++;
        
        if (workflow.status === 'completed') {
            this.performanceMetrics.successfulWorkflows++;
        } else if (workflow.status === 'error') {
            this.performanceMetrics.failedWorkflows++;
            
            // Track error types
            const errorType = workflow.error || 'Unknown';
            const currentCount = this.performanceMetrics.errorsByType.get(errorType) || 0;
            this.performanceMetrics.errorsByType.set(errorType, currentCount + 1);
        }
        
        // Update average execution time
        this.performanceMetrics.totalExecutionTime += workflow.duration;
        this.performanceMetrics.averageExecutionTime = this.performanceMetrics.totalExecutionTime / this.performanceMetrics.totalWorkflows;
    }

    /**
     * Add workflow to history
     */
    addToHistory(workflow) {
        this.workflowHistory.push({
            id: workflow.id,
            status: workflow.status,
            duration: workflow.duration,
            startTime: workflow.startTime,
            endTime: workflow.endTime,
            nodeCount: workflow.nodes.length,
            error: workflow.error || null
        });
        
        // Keep history size manageable
        if (this.workflowHistory.length > this.maxHistorySize) {
            this.workflowHistory.shift();
        }
    }

    /**
     * Get performance metrics
     */
    getMetrics() {
        return {
            ...this.performanceMetrics,
            successRate: this.performanceMetrics.totalWorkflows > 0 
                ? (this.performanceMetrics.successfulWorkflows / this.performanceMetrics.totalWorkflows * 100).toFixed(2) + '%'
                : '0%',
            averageExecutionTime: Math.round(this.performanceMetrics.averageExecutionTime),
            runningWorkflows: this.runningWorkflows.size,
            maxConcurrentWorkflows: this.config.workflow.maxConcurrentWorkflows
        };
    }

    /**
     * Get workflow history
     */
    getHistory(limit = 50) {
        return this.workflowHistory.slice(-limit);
    }

    /**
     * Stop a running workflow
     */
    stopWorkflow(workflowId) {
        const workflow = this.runningWorkflows.get(workflowId);

        if (!workflow) {
            return false;
        }

        // Set cancellation flag to interrupt execution
        workflow.cancelled = true;

        return true;
    }

    /**
     * Execute a single node
     */
    async executeNode(workflow, node, connections) {
        // INSTANT KILL SWITCH - Check cancellation before ANY processing
        if (workflow.cancelled) {
            throw new Error('Workflow cancelled');
        }

        const nodeId = node.id;
        const nodeType = node.type;
        
        // Check for cancellation before executing node
        if (workflow.cancelled) {
            throw new Error('Workflow cancelled');
        }
        
        console.log(`âš¡ Executing node: ${nodeType} (${nodeId})`);
        
        // Update node state
        const nodeState = workflow.executionState.get(nodeId) || { status: 'idle', data: {} };
        nodeState.status = 'running';
        nodeState.startTime = Date.now();
        workflow.executionState.set(nodeId, nodeState);
        
        this.broadcastNodeUpdate(workflow.id, nodeId, 'running', nodeState);

        try {
            // Get executor for this node type
            const executor = this.nodeExecutors.get(nodeType);
            if (!executor) {
                throw new Error(`No executor found for node type: ${nodeType}`);
            }

            // Execute the node
            const result = await executor(node, workflow, connections);
            
            // Update node state with results
            nodeState.status = 'completed';
            nodeState.endTime = Date.now();
            nodeState.duration = nodeState.endTime - nodeState.startTime;
            nodeState.result = result;
            workflow.executionState.set(nodeId, nodeState);
            
            this.broadcastNodeUpdate(workflow.id, nodeId, 'completed', nodeState);

            // Find and execute connected nodes
            await this.executeConnectedNodes(workflow, node, connections, result);
            
        } catch (error) {
            nodeState.status = 'error';
            nodeState.error = error.message;
            nodeState.endTime = Date.now();
            nodeState.duration = nodeState.endTime - nodeState.startTime;
            workflow.executionState.set(nodeId, nodeState);
            
            this.broadcastNodeUpdate(workflow.id, nodeId, 'error', nodeState);
            throw error;
        }
    }

    /**
     * Execute nodes connected to the output of the current node
     */
    async executeConnectedNodes(workflow, node, connections, data) {
        // Find all connections from this node's outputs
        const outputConnections = connections.filter(conn => 
            conn.from.nodeId === node.id
        );

        // Execute each connected node
        const executionPromises = outputConnections.map(async (connection) => {
            const targetNode = workflow.nodes.find(n => n.id === connection.to.nodeId);
            if (targetNode) {
                // Pass data to the target node
                const targetNodeState = workflow.executionState.get(targetNode.id) || { data: {} };
                targetNodeState.data[`input_${connection.to.portIndex}`] = data;
                workflow.executionState.set(targetNode.id, targetNodeState);
                
                await this.executeNode(workflow, targetNode, connections);
            }
        });

        await Promise.all(executionPromises);
    }

    /**
     * Stop a running workflow
     */
    stopWorkflow(workflowId) {
        const workflow = this.runningWorkflows.get(workflowId);
        if (workflow) {
            workflow.status = 'stopped';
            workflow.endTime = Date.now();
            workflow.duration = workflow.endTime - workflow.startTime;
            
            console.log(`â¹ï¸ Workflow stopped: ${workflowId}`);
            this.broadcastWorkflowUpdate(workflowId, 'stopped', workflow);
            
            this.runningWorkflows.delete(workflowId);
            return true;
        }
        return false;
    }

    /**
     * Broadcast workflow updates to clients
     */
    broadcastWorkflowUpdate(workflowId, status, data) {
        this.io.emit('workflow_update', {
            workflowId: workflowId,
            status: status,
            data: data,
            timestamp: Date.now()
        });
    }

    /**
     * Broadcast node updates to clients
     */
    broadcastNodeUpdate(workflowId, nodeId, status, data) {
        this.io.emit('node_update', {
            workflowId: workflowId,
            nodeId: nodeId,
            status: status,
            data: data,
            timestamp: Date.now()
        });
    }

    // ==================== NODE EXECUTORS ====================

    /**
     * Start Node - Entry point
     */
    async executeStart(node, workflow, connections) {
        console.log('ðŸš€ Workflow started');
        return { message: 'Workflow execution started' };
    }

    /**
     * End Node - Exit point
     */
    async executeEnd(node, workflow, connections) {
        console.log('ðŸ Workflow completed');
        return { message: 'Workflow execution completed' };
    }

    /**
     * Condition Node - Conditional branching
     */
    async executeCondition(node, workflow, connections) {
        const condition = node.config.condition || '';
        const operator = node.config.operator || 'equals';
        const value = node.config.value || '';
        
        // Simple condition evaluation (can be enhanced)
        let result = false;
        switch (operator) {
            case 'equals':
                result = condition === value;
                break;
            case 'not_equals':
                result = condition !== value;
                break;
            case 'contains':
                result = condition.includes(value);
                break;
            default:
                result = condition === value;
        }
        
        return { 
            condition: condition,
            operator: operator,
            value: value,
            result: result,
            branch: result ? 'true' : 'false'
        };
    }

    /**
     * Delay Node - Wait for specified time
     */
    async executeDelay(node, workflow, connections) {
        const duration = node.config.duration || 1000;
        const unit = node.config.unit || 'ms';
        
        let waitTime = duration;
        if (unit === 'seconds') waitTime *= 1000;
        else if (unit === 'minutes') waitTime *= 60000;
        
        console.log(`â±ï¸ Waiting ${waitTime}ms`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        
        return { 
            duration: waitTime,
            unit: unit,
            message: `Waited ${waitTime}ms`
        };
    }

    /**
     * Execute Python Node
     */
    async executePython(node, workflow, connections) {
        const code = node.config.code || '';
        const timeout = node.config.timeout || 30;
        
        console.log('ðŸ Executing Python code:', code.substring(0, 100) + '...');
        
        try {
            // Send execution request to Python agent
            const result = await this._executePythonCode(node.id, code, timeout);
            
            return {
                code: code,
                ...result,
                executionTime: result.executionTime || 0
            };
        } catch (error) {
            console.error('Python execution error:', error);
            throw error;
        }
    }

    /**
     * Monitor Function Node
     */
    async executeMonitorFunction(node, workflow, connections) {
        const functionName = node.config.functionName || '';
        const trackParams = node.config.trackParams !== false;
        const trackReturn = node.config.trackReturn !== false;
        
        console.log(`ðŸ‘ï¸ Monitoring Python function: ${functionName}`);
        
        try {
            // Send monitoring request to Python agent
            const result = await this._monitorPythonFunction(node.id, functionName, trackParams, trackReturn);
            
            return {
                functionName: functionName,
                ...result,
                monitoringActive: true
            };
        } catch (error) {
            console.error('Function monitoring error:', error);
            throw error;
        }
    }

    /**
     * Import Module Node
     */
    async executeImportModule(node, workflow, connections) {
        const moduleName = node.config.moduleName || '';
        const alias = node.config.alias || '';
        
        console.log(`ðŸ“¦ Importing module: ${moduleName}`);
        
        // Simulated module import
        return {
            moduleName: moduleName,
            alias: alias,
            loaded: true,
            exports: ['default', 'function1', 'function2']
        };
    }

    // ==================== PYTHON EXECUTION HELPERS ====================

    /**
     * Execute Python code via Python agent
     */
    _executePythonCode(nodeId, code, timeout) {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error('Python execution timeout'));
            }, timeout * 1000 + 5000); // Add buffer

            // Listen for response
            const handleResponse = (data) => {
                if (data.nodeId === nodeId) {
                    clearTimeout(timeoutId);
                    this.io.removeListener('node_execution_update', handleResponse);
                    
                    if (data.status === 'completed') {
                        resolve(data.result);
                    } else if (data.status === 'error') {
                        reject(new Error(data.error || 'Python execution failed'));
                    }
                }
            };

            this.io.on('node_execution_update', handleResponse);

            // Send execution request
            this.io.emit('execute_python_code', {
                nodeId: nodeId,
                code: code,
                timeout: timeout
            });
        });
    }

    /**
     * Monitor Python function via Python agent
     */
    _monitorPythonFunction(nodeId, functionName, trackParams, trackReturn) {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error('Function monitoring timeout'));
            }, 10000); // 10 second timeout for setup

            const handleResponse = (data) => {
                if (data.nodeId === nodeId) {
                    clearTimeout(timeoutId);
                    this.io.removeListener('node_execution_update', handleResponse);
                    
                    if (data.status === 'completed') {
                        resolve(data.result);
                    } else if (data.status === 'error') {
                        reject(new Error(data.error || 'Function monitoring failed'));
                    }
                }
            };

            this.io.on('node_execution_update', handleResponse);
    async executeReadFile(node, workflow, connections) {
        const filePath = node.config.filePath || '';
        const encoding = node.config.encoding || 'utf8';
        
        console.log(`ðŸ“– Reading file: ${filePath}`);
        
        // Simulate file reading
        const content = `Simulated content of ${filePath}`;
        
        return {
            filePath: filePath,
            encoding: encoding,
            content: content,
            size: content.length
        };
    }

    /**
     * Write File Node
     */
    async executeWriteFile(node, workflow, connections) {
        const filePath = node.config.filePath || '';
        const content = node.config.content || '';
        const encoding = node.config.encoding || 'utf8';
        
        console.log(`âœï¸ Writing file: ${filePath}`);
        
        // Simulate file writing
        return {
            filePath: filePath,
            encoding: encoding,
            content: content,
            bytesWritten: content.length,
            success: true
        };
    }

    /**
     * Run Command Node
     */
    async executeRunCommand(node, workflow, connections) {
        const command = node.config.command || '';
        const shell = node.config.shell || 'powershell';
        
        console.log(`âš¡ Running command: ${command}`);
        
        // Simulate command execution
        return {
            command: command,
            shell: shell,
            stdout: `Simulated output of: ${command}`,
            stderr: '',
            exitCode: 0
        };
    }

    /**
     * Show Message Node
     */
    async executeShowMessage(node, workflow, connections) {
        const title = node.config.title || 'Notification';
        const message = node.config.message || '';
        
        console.log(`ðŸ’¬ Showing message: ${title} - ${message}`);
        
        // Send notification to clients
        this.io.emit('notification', {
            title: title,
            message: message,
            type: 'info',
            timestamp: Date.now()
        });
        
        return {
            title: title,
            message: message,
            shown: true
        };
    }

    /**
     * Write Log Node
     */
    async executeWriteLog(node, workflow, connections) {
        const level = node.config.level || 'info';
        const message = node.config.message || '';
        const logFile = node.config.logFile || 'runtime.log';
        
        console.log(`ðŸ“‹ Writing log: [${level}] ${message}`);
        
        return {
            level: level,
            message: message,
            logFile: logFile,
            timestamp: new Date().toISOString(),
            logged: true
        };
    }

    // Placeholder implementations for remaining nodes
    async executeLoop(node, workflow, connections) {
        return { message: 'Loop execution simulated' };
    }

    async executeMonitorFunction(node, workflow, connections) {
        return { message: 'Function monitoring simulated' };
    }

    /**
     * Delay Node
     */
    async executeDelay(node, workflow, connections) {
        const duration = node.config.duration || 1000;
        const unit = node.config.unit || 'ms';
        
        let waitTime = duration;
        if (unit === 'seconds') waitTime *= 1000;
        else if (unit === 'minutes') waitTime *= 60000;
        
        console.log(`â±ï¸ Waiting ${duration} ${unit}`);
        
        // KILL SWITCH - Check cancellation before starting timer
        if (workflow.cancelled) {
            throw new Error('Workflow cancelled');
        }
        
        // Single timer with immediate cancellation capability
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                // CRITICAL: Check cancellation again inside the callback
                if (workflow.cancelled) {
                    reject(new Error('Workflow cancelled'));
                    return;
                }
                
                resolve({
                    duration: duration,
                    unit: unit,
                    waitTime: waitTime,
                    completed: true
                });
            }, waitTime);
            
            // Store timeout ID for cleanup
            workflow._timeoutId = timeoutId;
        });
    }

    async executeListDirectory(node, workflow, connections) {
        return { files: ['file1.txt', 'file2.txt'], directories: ['dir1', 'dir2'] };
    }

    async executeStartProcess(node, workflow, connections) {
        return { processId: 1234, status: 'started' };
    }

    async executeKillProcess(node, workflow, connections) {
        return { processId: 1234, status: 'killed' };
    }

    async executeHTTPRequest(node, workflow, connections) {
        return { status: 200, data: 'Simulated response' };
    }

    async executeDownloadFile(node, workflow, connections) {
        return { filePath: '/path/to/downloaded/file', size: 1024 };
    }

    async executeTransformJSON(node, workflow, connections) {
        return { transformed: 'Simulated JSON transformation' };
    }

    async executeParseText(node, workflow, connections) {
        return { matches: ['match1', 'match2'] };
    }

    async executeSQLQuery(node, workflow, connections) {
        return { rows: [{ id: 1, name: 'test' }] };
    }

    async executeKeyboardInput(node, workflow, connections) {
        return { keys: 'simulated keys', sent: true };
    }

    async executeEncryptData(node, workflow, connections) {
        return { encrypted: 'simulated encrypted data' };
    }

    addToHistory(workflow) {
        const historyEntry = {
            ...workflow,
            nodeCount: workflow.nodes ? workflow.nodes.length : 0
        };

        this.workflowHistory.push(historyEntry);

        // Limit history size
        if (this.workflowHistory.length > this.maxHistorySize) {
            this.workflowHistory.shift();
        }
    }

    stopWorkflow(workflowId) {
        const workflow = this.runningWorkflows.get(workflowId);
        if (!workflow) {
            return false;
        }

        workflow.status = 'stopped';
        workflow.endTime = Date.now();
        workflow.duration = workflow.endTime - workflow.startTime;
        
        this.addToHistory(workflow);
        this.runningWorkflows.delete(workflowId);
        
        // Broadcast workflow stopped event if IO is available
        if (this.io && this.io.emit) {
            this.io.emit('workflowStopped', workflow);
        }
        return true;
    }

    processQueue() {
        if (this.isProcessing || this.executionQueue.length === 0) {
            return;
        }

        this.isProcessing = true;
        
        while (this.executionQueue.length > 0 && 
               this.runningWorkflows.size < this.config.workflow.maxConcurrentWorkflows) {
            const workflow = this.executionQueue.shift();
            if (workflow) {
                this.startWorkflow(workflow);
            }
        }
        
        this.isProcessing = false;
    }
}

module.exports = WorkflowEngine;
